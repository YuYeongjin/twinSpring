# -*- coding: utf-8 -*-
"""wallet.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1k-JU93s5-2BHjcP-AIG0d-jobI43a67M
"""

!pip install langgraph==0.3.18
!pip install langchain-community==0.3.20
!pip install langchain-teddynote ==0.3.44

from typing import TypedDict, Annotated, List, Optional
from langchain_core.documents import Document
from langgraph.graph.message import add_messages

class GraphState(TypedDict):
    input: str                 # 사용자 프롬프트/질문
    transaction_data: dict          # 데이터
    avg_data: dict             # DB 평균 데이터
    risk_score: Optional[float]       # ML 산출 스코어
    response: Optional[str]    # 최종 응답(JSON 문자열)

from IPython.display import Image,display
def show_graph(graph):
  try:
    display( Image(graph.get_graph().draw_mermaid_png()))

  except Exception:
    pass

from sqlalchemy import create_engine
from langchain_community.utilities import SQLDatabase
from langchain_community.chat_models import ChatOllama


llm = ChatOllama(
    model="llama3.1:8b",
    # model="gemma:2b",
    temperature=0,
    base_url="http://127.0.0.1:11434"
)

from langchain.chains import SQLDatabaseChain
# Database 연결
db = SQLDatabase.from_uri("mysql+pymysql://root:Abcd1234@localhost:3306/dallas_wallet_v2")
db_chain = SQLDatabaseChain.from_llm(llm, db, verbose=True)

from sklearn.ensemble import IsolationForest
# 머신러닝 테스트
X_train = np.array([
    [10000, 14, 0.5, 2.0, 0],   # 정상 거래 샘플 (amount, hour, zscore, geo_distance, is_new_device)
    [15000, 11, 0.2, 1.0, 0],
    [20000, 16, 0.1, 3.0, 0],
    [5000, 9, -0.3, 0.5, 0]
])
model = IsolationForest(random_state=42, contamination=0.05)
model.fit(X_train)

def initCheck(state: GraphState) -> GraphState:
    prompt = (
        f'DB/LLM에서 얻은 정보:\n"{to_text(state.get("avg_data"))}"\n\n'
        f'거래 데이터: "{to_text(state.get("transaction_data"))}"\n'
        f"이상 거래를 체크할건데, 안전, 주의, 경고"
        f"3개로 분류한 결과만 보여줘"

    )
    result = llm.invoke(prompt)
    print_now("init check")
    return {"response": result.content}

def db_retrieve(state: GraphState) -> GraphState:
    prompt = (
        "사용자의 이상거래 탐지를 위해 아래의 항목들의 평균값이 필요해"
        "1. 금액 (amount)"
        "2. 거래 시각 (hour)"
        "3. 사용자 최근 평균 금액 대비 (z-score)"
        "4. 사용자 기본 지역과의 거리 (geo_distance)"
        "5. 신규 기기 여부 (is_new_device: 0/1)"
        "데이터베이스를 조회해서 가져와볼래"
    )
    result = db_chain.invoke(prompt)
    print_now("db_Retrieve")
    return {"response" : result.content}

def initBranch(state: GraphState) -> str:
    return "mlCheck" if state.get("avg_data") else "db_retrieve"



def mlCheck(state: GraphState) -> GraphState:
    tx = state["transaction_data"]
    avg = state["avg_data"]

    # 피처 벡터 구성
    vec = np.array([[
        tx["amount"],
        tx["hour"],
        (tx["amount"] - avg["avg_amount"]) / (avg["std_amount"]+1e-6),  # z-score
        tx["geo_distance"],
        1 if tx["is_new_device"] else 0
    ]])

    score = model.decision_function(vec)[0]
    risk_score = float(-score)  # 음수일수록 이상 → 반전
    state["risk_score"] = risk_score
    return state


def end_chain(state: GraphState) -> GraphState:
    prompt = PromptTemplate.from_template("""
    다음 거래 데이터를 이상거래 여부로 평가해.
    
    [거래 데이터]
    {tx}
    
    [평균 기준 데이터]
    {avg}
    
    [ML 산출 스코어]
    {score}
    
    안전 / 주의 / 경고 중 하나로 분류하고, 간단한 근거 제시
    """)

    chain = LLMChain(llm=llm, prompt=prompt)
    result = chain.run({
        "tx": state["transaction_data"],
        "avg": state["avg_data"],
        "score": state["risk_score"]
    })
    state["response"] = result
    return

from langgraph.graph import StateGraph

builder = StateGraph(GraphState)
builder.add_node("initCheck", initCheck)
builder.add_node("db_retrieve",db_retrieve)
builder.add_node("mlCheck", mlCheck)
builder.add_node("end_chain", end_chain)
builder.set_entry_point("initCheck")
builder.add_conditional_edges("initCheck", initBranch, {
    "mlCheck": "mlCheck",
    "db_retrieve": "db_retrieve",
})
builder.add_edge("db_retrieve","mlCheck")
builder.add_edge("mlCheck","end_chain")
builder.set_finish_point("end_chain")
graph = builder.compile()
